// Generated by CoffeeScript 1.7.1
(function() {
  var Master, Worker, cp, events, exports,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  cp = require('child_process');

  Worker = require('./worker');

  events = require('events');

  Master = (function(_super) {
    __extends(Master, _super);

    function Master() {
      var worker;
      this.isWorker = process.env.EVENT_CLUSTER_MASTER_PID ? true : false;
      this.isMaster = !this.isWorker;
      this.functions = {};
      this.workers = {};
      this.listeningWorkers = [];
      this.pid = process.pid;
      this.queue = [];
      this.cmd = process.argv.slice(1);
      if (this.isMaster) {
        process.env.EVENT_CLUSTER_MASTER_PID = this.pid;
        console.log("Master starts at " + this.pid);
      }
      if (this.isWorker) {
        worker = new Worker(this);
        worker.start();
      }
    }

    Master.prototype.forks = function(n) {
      var i, _i, _results;
      if (n == null) {
        n = 1;
      }
      _results = [];
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        _results.push(this.fork());
      }
      return _results;
    };

    Master.prototype.fork = function() {
      var worker;
      worker = new Worker(this);
      worker.fork();
      return this.register(worker);
    };

    Master.prototype.use = function(id, fn) {
      return this.functions[id] = fn;
    };

    Master.prototype.pushQ = function(id, target) {
      this.queue.push({
        id: id,
        target: target
      });
      return this.tasker();
    };

    Master.prototype.sendMessage = function(pid, message) {
      var worker;
      worker = this.workers[pid];
      return worker.proc.send(message);
    };

    Master.prototype.register = function(worker) {
      var pid;
      pid = worker.proc.pid;
      this.workers[pid] = worker;
      worker.proc.on('message', (function(_this) {
        return function(message) {
          return _this.handleWorkerMessage(message);
        };
      })(this));
      return this.sendMessage(pid, {
        type: 'register',
        pid: pid
      });
    };

    Master.prototype.handleWorkerMessage = function(message) {
      switch (message.type) {
        case 'pullTask':
          this.pullTask(message.pid);
          return this.emit('pullTask', {
            pid: message.pid
          });
        case 'result':
          return this.emit('result', {
            result: message.result,
            task: messagetask
          });
        case 'message':
          return console.log(message.message);
        case 'working':
          return this.emit('workerStart', {
            pid: message.pid
          });
        case 'exit':
          return console.log("worker: " + message.pid + " shutdown!");
        case 'error':
          console.log(message.errorType);
          switch (message.errorType) {
            case 'registerFailed':
              this.fork();
              return console.log('worker restart');
            case 'dealFailed':
              this.pullTask(message.task.id, message.task.target);
              return console.log('repush task');
          }
      }
    };

    Master.prototype.pullTask = function(pid) {
      if (pid) {
        this.listeningWorkers.push(pid);
        return this.tasker();
      }
    };

    Master.prototype.tasker = function() {
      var pid, task;
      if (this.listeningWorkers.length > 0) {
        if (this.queue.length > 0) {
          task = this.queue.shift();
          pid = this.listeningWorkers.shift();
          this.deal(task, pid);
          if (this.queue.length > 0) {
            return this.tasker();
          }
        }
      }
    };

    Master.prototype.deal = function(task, pid) {
      var fn;
      console.log("worker: " + pid + " deal with task: " + task.id);
      this.sendMessage(pid, {
        type: 'deal',
        task: task
      });
      fn = this.functions[task.id];
      fn(task.target);
      return this.pullTask(pid);
    };

    Master.prototype.remove = function() {
      var i, _i, _len, _ref;
      _ref = this.workers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        this.sendMessage(i({
          type: 'exit'
        }));
      }
      return console.log('All of workers has exited!');
    };

    return Master;

  })(events.EventEmitter);

  exports = module.exports = Master;

}).call(this);
